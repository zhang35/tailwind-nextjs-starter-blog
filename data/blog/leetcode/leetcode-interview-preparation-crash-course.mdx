---
title: LeetCode Interview Preparation Crash Course
date: '2025-10-28'
tags: ['leetcode', 'interview-prep', 'algorithms', 'data-structures']
---

# LeetCode Interview Preparation Crash Course

A comprehensive collection of curated LeetCode problems organized by pattern and data structure to efficiently prepare for technical interviews. Each problem includes detailed explanations, multiple approaches, time/space complexity analysis, and key insights.

## How to Use This Guide

1. **Start with fundamentals** - Begin with Array, Two Pointers, and Binary Search
2. **Master patterns** - Focus on understanding the pattern, not memorizing solutions
3. **Practice consistently** - Do at least 1-2 problems daily
4. **Review regularly** - Revisit problems to reinforce patterns
5. **Code without looking** - Try to solve from memory to ensure understanding

## Study Plan Recommendation

### Week 1-2: Fundamentals
- Array & Sliding Window
- Two Pointers
- Binary Search
- Stack & Queue

### Week 3-4: Trees & Graphs
- Binary Tree
- Graph Algorithms (BFS, DFS, Topological Sort)

### Week 5-6: Advanced Patterns
- Dynamic Programming
- Backtracking
- Heap/Priority Queue

### Week 7-8: Specialized Topics
- Trie
- Greedy Algorithms
- Sorting Algorithms
- String Manipulation

---

## üìö Topics Overview

### 1. Array (7 problems)
**Key Patterns:** Kadane's Algorithm, Prefix/Suffix, Sliding Window, Monotonic Deque, Intervals

- [**Two Sum**](/blog/leetcode/array/two-sum) (LC 1) - Hash map for pair finding
- **Maximum Subarray** (LC 53) - Kadane's algorithm for max sum subarray
- [**Merge Intervals**](/blog/leetcode/array/merge-intervals) (LC 56) - Sorting + merging intervals
- [**Maximum Gap**](/blog/leetcode/array/maximum-gap) (LC 164) - Bucket sort optimization
- [**Contains Duplicate II**](/blog/leetcode/array/contains-duplicate-ii) (LC 219) - Sliding window with hash map
- **Product of Array Except Self** (LC 238) - Prefix/suffix products
- **Sliding Window Maximum** (LC 239) - Monotonic deque for window extremes
- [**Flatten 2D Vector**](/blog/leetcode/array/flatten-2d-vector) (LC 251) - Iterator design pattern
- [**Pour Water**](/blog/leetcode/array/pour-water) (LC 755) - Simulation with two-pointer

**When to use:** Array traversal, subarray problems, window-based optimization, interval problems

---

### 2. Two Pointers (2 problems)
**Key Patterns:** Left-Right pointers, Fast-Slow pointers, Greedy movement

- **Container With Most Water** (LC 11) - Greedy two-pointer strategy
- [**3Sum**](/blog/leetcode/two-pointer/3sum) (LC 15) - Two pointers with sorting
- [**Trapping Rain Water**](/blog/leetcode/two-pointer/trapping-rain-water) (LC 42) - Two pointers tracking max heights

**When to use:** Sorted arrays, pair finding, optimization problems

---

### 3. Binary Search (6 problems)
**Key Patterns:** Standard binary search, Rotated array search, Finding boundaries, Median finding

- [**Median of Two Sorted Arrays**](/blog/leetcode/binary-search/median-two-sorted-arrays) (LC 4) - Binary search for kth element
- [**Search in Rotated Sorted Array**](/blog/leetcode/binary-search/search-in-rotated-sorted-array) (LC 33) - Modified binary search
- [**Search Rotated Array II**](/blog/leetcode/binary-search/search-rotated-array-ii) (LC 81) - With duplicates
- [**Find Minimum in Rotated Sorted Array**](/blog/leetcode/binary-search/find-minimum-in-rotated-sorted-array) (LC 153) - Finding rotation point
- [**Find Peak Element**](/blog/leetcode/binary-search/find-peak-element) (LC 162) - Binary search on unsorted
- [**Binary Search**](/blog/leetcode/binary-search/binary-search) (LC 704) - Classic binary search template

**When to use:** Sorted/rotated arrays, finding boundaries, optimization (minimize/maximize)

---

### 4. Binary Tree (5 problems)
**Key Patterns:** DFS traversals, BFS level-order, Recursion, BST properties

- **Binary Tree Inorder Traversal** (LC 94) - Tree traversal fundamentals
- **Validate BST** (LC 98) - BST validation with range constraints
- **Level Order Traversal** (LC 102) - BFS with level tracking
- **Maximum Depth** (LC 104) - DFS depth calculation
- [**Convert Sorted Array to BST**](/blog/leetcode/binary-tree/sorted-array-to-bst) (LC 108) - Balanced BST construction
- [**Binary Tree Maximum Path Sum**](/blog/leetcode/binary-tree/maximum-path-sum) (LC 124) - Post-order DFS
- **Lowest Common Ancestor** (LC 236) - Bottom-up DFS
- [**Serialize and Deserialize Binary Tree**](/blog/leetcode/binary-tree/serialize-deserialize) (LC 297) - Tree encoding

**When to use:** Tree problems, hierarchical data, path finding

---

### 5. Graph (13 problems)
**Key Patterns:** DFS/BFS, Cycle detection, Topological sort, Connected components, Shortest path

- [**Word Ladder**](/blog/leetcode/graph/word-ladder) (LC 127) - BFS shortest path
- [**Word Ladder II**](/blog/leetcode/graph/word-ladder-ii) (LC 126) - BFS + backtracking
- [**Longest Consecutive Sequence**](/blog/leetcode/graph/longest-consecutive-sequence) (LC 128) - Union-find or hash set
- [**Clone Graph**](/blog/leetcode/graph/clone-graph) (LC 133) - Graph cloning with HashMap
- [**Number of Islands**](/blog/leetcode/graph/number-of-islands) (LC 200) - DFS/BFS for connected components
- [**Course Schedule**](/blog/leetcode/graph/course-schedule) (LC 207) - Cycle detection, topological sort
- [**Alien Dictionary**](/blog/leetcode/graph/alien-dictionary) (LC 269) - Topological sort
- [**Number of Connected Components**](/blog/leetcode/graph/connected-components) (LC 323) - Union-find
- [**Longest Increasing Path in Matrix**](/blog/leetcode/graph/longest-increasing-path-matrix) (LC 329) - DFS with memoization
- [**Pacific Atlantic Water Flow**](/blog/leetcode/graph/pacific-atlantic-water-flow) (LC 417) - Multi-source DFS
- [**Network Delay Time**](/blog/leetcode/graph/network-delay-time) (LC 743) - Dijkstra's algorithm
- [**Sliding Puzzle**](/blog/leetcode/graph/sliding-puzzle) (LC 773) - BFS on state space
- [**Cheapest Flights Within K Stops**](/blog/leetcode/graph/cheapest-flights-k-stops) (LC 787) - Modified Dijkstra

**When to use:** Relationship problems, dependencies, reachability, shortest paths

---

### 6. Dynamic Programming (8 problems)
**Key Patterns:** Optimal substructure, Overlapping subproblems, State transitions

- [**Regular Expression Matching**](/blog/leetcode/dp/regular-expression-matching) (LC 10) - 2D DP with wildcards
- [**Longest Palindromic Substring**](/blog/leetcode/dp/longest-palindromic-substring) (LC 5) - Expand around center / DP
- [**Climbing Stairs**](/blog/leetcode/dp/climbing-stairs) (LC 70) - Basic DP / Fibonacci
- [**House Robber**](/blog/leetcode/dp/house-robber) (LC 198) - DP with choice
- [**Maximal Square**](/blog/leetcode/dp/maximal-square) (LC 221) - 2D DP
- [**Longest Increasing Subsequence**](/blog/leetcode/dp/longest-increasing-subsequence) (LC 300) - Classic DP with O(n log n) optimization
- [**Burst Balloons**](/blog/leetcode/dp/burst-balloons) (LC 312) - Interval DP
- [**Coin Change**](/blog/leetcode/dp/coin-change) (LC 322) - Unbounded knapsack

**When to use:** Optimization problems, counting problems, decision-making with constraints

---

### 7. Backtracking (7 problems)
**Key Patterns:** Choose-Explore-Unchoose, State restoration, Constraint satisfaction

- [**Letter Combinations of Phone Number**](/blog/leetcode/backtrack/letter-combinations-of-a-phone-number) (LC 17) - Basic backtracking
- [**Generate Parentheses**](/blog/leetcode/backtrack/generate-parentheses) (LC 22) - Backtracking with constraints
- [**Combination Sum**](/blog/leetcode/backtrack/combination-sum) (LC 39) - Backtracking with reusable elements
- [**Permutations**](/blog/leetcode/backtrack/permutations) (LC 46) - Generating all permutations
- [**N-Queens**](/blog/leetcode/backtrack/n-queens) (LC 51) - Constraint satisfaction
- [**Subsets**](/blog/leetcode/backtrack/subsets) (LC 78) - Power set generation
- [**Pyramid Transition Matrix**](/blog/leetcode/backtrack/pyramid-transition) (LC 756) - DFS with pruning

**When to use:** Generating combinations/permutations, constraint satisfaction, exhaustive search

---

### 8. Heap / Priority Queue (7 problems)
**Key Patterns:** Top K, K-way merge, Two heaps, Streaming median

- [**Merge K Sorted Lists**](/blog/leetcode/heap/merge-k-sorted-lists) (LC 23) - K-way merge with heap
- [**Kth Largest Element**](/blog/leetcode/heap/kth-largest-element) (LC 215) - Min-heap for Kth largest
- [**Find Median from Data Stream**](/blog/leetcode/heap/find-median-from-data-stream) (LC 295) - Two heaps (max + min)
- [**Top K Frequent Elements**](/blog/leetcode/heap/top-k-frequent-elements) (LC 347) - Heap + HashMap
- [**Data Stream as Disjoint Intervals**](/blog/leetcode/heap/data-stream-disjoint-intervals) (LC 352) - Heap + TreeMap
- [**LFU Cache**](/blog/leetcode/design/lfu-cache) (LC 460) - Heap-like with hash maps
- [**Sliding Window Median**](/blog/leetcode/heap/sliding-window-median) (LC 480) - Two heaps sliding

**When to use:** Top K problems, merging sorted data, streaming data, priority-based processing

---

### 9. Trie (2 problems)
**Key Patterns:** Prefix operations, Dictionary operations, Word search optimization

- **Implement Trie** (LC 208) - Basic trie implementation
- [**Word Search II**](/blog/leetcode/trie/word-search-ii) (LC 212) - Trie + DFS backtracking
- [**Design File System**](/blog/leetcode/design/file-system) (Custom) - Trie for path operations

**When to use:** Prefix matching, autocomplete, dictionary operations, word search optimization

---

### 10. Stack & Queue (3 problems)
**Key Patterns:** Matching pairs, Monotonic stack, Next greater/smaller element

- [**Valid Parentheses**](/blog/leetcode/stack-queue/valid-parentheses) (LC 20) - Stack for matching
- **Min Stack** (LC 155) - Auxiliary stack for O(1) operations
- **Daily Temperatures** (LC 739) - Monotonic stack

**When to use:** Matching/balancing, maintaining order, next greater/smaller problems

---

### 11. Greedy (3 problems)
**Key Patterns:** Local optimal choices, Proof of correctness, Scheduling

- [**Jump Game**](/blog/leetcode/greedy/jump-game) (LC 55) - Greedy reachability
- [**Meeting Rooms II**](/blog/leetcode/greedy/meeting-rooms-ii) (LC 253) - Greedy scheduling with heap
- [**Employee Free Time**](/blog/leetcode/greedy/employee-free-time) (LC 759) - Interval merging

**When to use:** Optimization where local choices lead to global optimum, scheduling

---

### 12. Sorting (2 problems)
**Key Patterns:** Divide and conquer, Partitioning, Comparison-based sorting

- **Merge Sort** - Stable O(n log n) sort
- **Quick Sort** - In-place O(n log n) average sort

**When to use:** Understanding sorting fundamentals, custom comparators, external sorting

---

### 13. String (5 problems)
**Key Patterns:** Sliding window, Character frequency, Two pointers, Palindrome, Trie

- [**Longest Substring Without Repeating Characters**](/blog/leetcode/string/longest-substring-without-repeating-characters) (LC 3) - Sliding window
- [**Valid Anagram**](/blog/leetcode/string/valid-anagram) (LC 242) - Character frequency
- [**Palindrome Pairs**](/blog/leetcode/string/palindrome-pairs) (LC 336) - Trie + palindrome checking
- [**Palindromic Substrings**](/blog/leetcode/string/palindromic-substrings) (LC 647) - Expand around center
- [**IP to CIDR**](/blog/leetcode/string/ip-to-cidr) (LC 751) - Bit manipulation

**When to use:** Substring problems, character manipulation, pattern matching

---

### 14. Linked List (3 problems)
**Key Patterns:** Two pointers, Dummy node, In-place reversal, LRU design

- **Reverse Linked List II** (LC 92) - In-place reversal
- [**LRU Cache**](/blog/leetcode/design/lru-cache) (LC 146) - Doubly linked list + hash map
- **Sort Linked List** (LC 148) - Merge sort for linked lists
- [**Intersection of Two Linked Lists**](/blog/leetcode/linked-list/intersection-two-lists) (LC 160) - Two pointers

**When to use:** List manipulation, reversal, sorting without arrays

---

### 15. Divide and Conquer (1 problem)
**Key Patterns:** Break into subproblems, Combine solutions

- **Sort Linked List** (LC 148) - Merge sort pattern

**When to use:** Problems that can be broken into independent subproblems

---

## üéØ Quick Reference: Pattern Recognition

### When you see these keywords, think:

- **"Contiguous subarray"** ‚Üí Sliding Window, Kadane's Algorithm
- **"Two sum, three sum"** ‚Üí Two Pointers, Hash Map
- **"Sorted array"** ‚Üí Binary Search, Two Pointers
- **"Tree traversal"** ‚Üí DFS, BFS
- **"Shortest path"** ‚Üí BFS, Dijkstra
- **"Connected components"** ‚Üí DFS, BFS, Union-Find
- **"Optimal/Maximum/Minimum with choices"** ‚Üí Dynamic Programming, Greedy
- **"All possible combinations"** ‚Üí Backtracking
- **"Top K elements"** ‚Üí Heap
- **"Prefix matching"** ‚Üí Trie
- **"Next greater/smaller"** ‚Üí Monotonic Stack
- **"Matching pairs"** ‚Üí Stack
- **"Window of unique elements"** ‚Üí Sliding Window + Hash Set

---

## üìä Complexity Cheat Sheet

### Common Time Complexities (from best to worst):
- O(1) - Constant
- O(log n) - Logarithmic (Binary Search, Balanced Tree operations)
- O(n) - Linear (Array traversal, Hash Table lookup)
- O(n log n) - Linearithmic (Efficient sorting, Heap operations on n items)
- O(n¬≤) - Quadratic (Nested loops)
- O(2‚Åø) - Exponential (Recursive branching without memoization)
- O(n!) - Factorial (Permutations)

### Space Complexity Considerations:
- Recursion depth contributes to space complexity
- Hash maps trade space for time
- In-place algorithms are space-optimal but may be harder to implement

---

## üîë Key Interview Tips

1. **Clarify the problem** - Ask about edge cases, constraints, input format
2. **Think out loud** - Communicate your thought process
3. **Start with brute force** - Then optimize
4. **Consider time-space tradeoffs** - Sometimes using more space gives better time
5. **Test with examples** - Walk through your solution with test cases
6. **Discuss edge cases** - Empty input, single element, duplicates, etc.
7. **Know your complexities** - Always analyze time and space complexity

---

## üìà Progress Tracking

Total Problems: **70+** (with detailed solutions and explanations)

Suggested completion order:
1. ‚úì Complete all Array, Two Pointers, Binary Search (Foundation)
2. ‚úì Master Binary Tree and Stack/Queue (Essential data structures)
3. ‚úì Practice Graph problems (Common in interviews)
4. ‚úì Tackle Dynamic Programming (Most challenging)
5. ‚úì Learn Backtracking patterns (Combination problems)
6. ‚úì Understand Heap operations (Top K problems)
7. ‚úì Review Trie, Greedy, Sorting (Specialized patterns)

---

## üöÄ Next Steps After This Crash Course

1. **Do more variations** - Each pattern has 10-20 more problems on LeetCode
2. **Practice mock interviews** - Use platforms like Pramp, interviewing.io
3. **Review company-specific patterns** - Check Blind 75, Grind 75
4. **Build projects** - Apply algorithms to real problems
5. **Contribute to discussions** - Teach others to reinforce learning

---

## üìñ Additional Resources

- [LeetCode Patterns](https://seanprashad.com/leetcode-patterns/)
- [NeetCode Roadmap](https://neetcode.io/roadmap)
- [Blind 75](https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU)
- [Visualgo](https://visualgo.net/) - Algorithm visualizations

---

**Remember:** The goal isn't to memorize solutions, but to recognize patterns and understand the underlying principles. Happy coding! üéâ
